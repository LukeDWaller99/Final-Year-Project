\section{Software Design}
\subsection{Controller}
\subsubsection{Architecture}


The Controller is entierly multi-threaded. The decision was taken to use  multithreaded architecture due to the nature of the system being used; monitoring and controlling sensors with interupts coming from multiple sources. A single threaded architecture was initially used during inital testing. This was found to be impractical as the statemachine used became cumbersome. When communicating using \gls{rf} the controller could not respond to any other commands from any oher devices. This may not have been quick enough to react to any other inputs from the user. 

Because of this, the controller architecture was split into threads, listed in Table \ref{table:threads_for_controller}. Each entry in the table is represented by a thread in the program that is initialised during start-up. 

\begin{table}[H]
\centering
\setlength{\arrayrulewidth}{1.5pt}
\begin{tabular}{|p{0.4\linewidth}|p{0.4\linewidth}|}
\hline
\cellcolor{gray!40}Thread Name & \cellcolor{gray!40}Function \\ 
\hline
\cellcolor{gray!20}Pot Thread & \cellcolor{gray!20}Polls Values of the Joysticks and sends over \gls{rf}\\
\hline
\cellcolor{gray!20}Input Thread & \cellcolor{gray!20}Used to handle inputs when flags raised\\
\hline
\end{tabular}
\caption{Threads for Controller}
\label{table:threads_for_controller}
\end{table}

\subsubsection{Serial Communications}\label{sec:serial_communication_1}
The serial communication for this project was done over \gls{spi} using nRF24L01 modules to send data. As there was already an nRF24L01 library written for Mbed \cite{nRF24L01_lib_ref}. This abstracted the serial interface from the user to just writing to the \gls{rf} devices, and allowing the library to handle the rest. 

This library was externally written and whilst it was functional, it was a bit rough around the edges and felt, in parts, to be unfinished. Whilst this functionality was not used, it would have been nice to have a complete library. Despite this, the library was operational and only required the data to be sent across using char arrays, whilst fiddly this was not too difficult to achieve. 

This library could have been re-written to include its missing functionality, but this would have taken up a significant amount of the project given that the serial/\gls{rf} communication was not the main objective.     

Despite the class being functionality incomplete, it was easy to use for sending data using radio. Code \ref{code:nRF24L01_declaration} shows how to create the object for the nRF24L01 Class. It requires the use of an \gls{spi} interface on the board.  

\begin{lstlisting}[language=C++,label=code:nRF24L01_declaration,caption=nRF24L01 Class Constructor]
#include <nRF24L01P.h>
nRF24L01P radio(MOSI, MISO, SCK, CSN, CE, IRQ);
\end{lstlisting}

Once the object is declared, the code in Code \ref{code:nRF24L01_SETUP} is then used to set up the nRF24L01 so that it can be used correctly. 

\begin{lstlisting}[language=C++,label=code:nRF24L01_SETUP,caption=nRF24L01 Set Up Transmit Mode]
radio.powerUp();
radio.setTransferSize(TRANSFER_SIZE);
radio.setAirDataRate(NRF24L01P_DATARATE_2_MBPS);
radio.setRxAddress(NRF24L01_RX_ADDRESS);
radio.setTxAddress(NRF24L01_TX_ADDRESS);
radio.setTransmitMode();
radio.enable();
\end{lstlisting}

Code \ref{code:nRF24L01_send_data} shows how the data is written to the nRF24L01 module. This requires the data to be in a char array format, ideally the module would allow strings and integers to be passed to it, but the use of char arrays was acceptable.

\begin{lstlisting}[language=C++,label=code:nRF24L01_send_data,caption=Sending Data Using nRF24L01]
radio.write(char *data, int pipe, int count);
\end{lstlisting}

The serial communication was conducted using custom transmission protocols, outlined in Appendix \ref{app:transmission_codes}. These were designed to be short, 5-bits, and easy to extract the data from on the other end. This system was used to make the transfer of  data to faster and efficient with hopefully minimal packet loss.

\subsubsection{Buzzer API}\label{sec:buzzer_api}

The buzzer used for this project is a standard piezo buzzer that required a \gls{pwm} pin to drive at a given frequency. To make the buzzer audible and fit within the western standard of music notation, a class was written to to encapsulate the buzzer functionality, allowing the buzzer to be easily used. 

This buzzer class was inspired by the University of Plymouth's buzzer class written for the Module Support Board. 

This class has been written such that it is thread safe. The object-oriented nature of the class has allowed the class and code to be utilised on both the controller and receiver, both of which utilise buzzers as a method of alerting the user. 

\begin{lstlisting}[language=C++,label=code:buzzer_decleration,caption= Buzzer Class Constructor]
#include "Buzzer.h"
Buzzer buzzer(BUZZER);
\end{lstlisting}

Using this \gls{api}, the buzzer could be turned on or off, the note can be changed, and the octave the note is in can also be changed. This allowed multiple different alerts to the user to be utilised. This increased the versatility of the buzzer. 

This class includes operator overloads such that using the buzzer is easy and intuitive.

\subsubsection{Main Code}

The main code on the controller board runs in two separate threads, one for monitoring the button and switch states, and one for monitoring the joysticks and extracting their relative positional data. 

They three buttons and switch are all driven using interrupts. When the interrupts are triggered, the \gls{isr} raises a thread flag which wakes up the thread. The thread then handles this flag then going back into the waiting state where the thread is put to sleep and not scheduled until another event flag is triggered. 

Being an \href{https://os.mbed.com/docs/mbed-os/v6.15/apis/i-o-apis.html}{analogue inputs}, the joysticks cannot be run using the same interrupt based methodology. The joysticks were run using a \href{https://os.mbed.com/docs/mbed-os/v6.15/apis/ticker.html}{ticker}. The ticker is set to create an interrupt every 200ms and runs the joystick ticker \gls{isr}. This wakes up the joystick thread, polls the joystick values, if required it sends the values of \gls{spi} to the nRF24L01 then puts the thread back to sleep until the next ticker interrupt.

If the joystick values have not changed, the new joystick values get stored and then the thread goes back to sleep. This helps reduce power usage and \gls{rf} usage when unnecessary.

\begin{lstlisting}[language=C++,label=code:joysitck_value,caption= Joystick Value to Serial Data to be Sent]
newLeftPitchVal = abs(newLeftPitchVal);
sprintf(tempThrottleChar, "%d", newLeftPitchVal);
fwdLeftPitch[3] = tempThrottleChar[0];
radio.write(fwdLeftPitch, DEFAULT_PIPE, TRANSFER_SIZE);  
\end{lstlisting}

Code \ref{code:joysitck_value} shows the method of tansfering the data from integer form into the char array that is required to send data over the nRF24L01 device. This is an example of how this library could have been improved for this project. If the nRF24L01 library was able to accept integers to be sent, the code on the controller could have been simpler and easier to understand. 

Despite its complexity, the code for extracting the joystick values worked repeatable and did not cause any detectable false readings.
                

\subsection{Receiver}
\subsubsection{Architecture}

The Receiver is entirely multi-threaded. The decision was taken to use a multithreaded architecture due to the nature of the system being used; controlling multiple real time devices that, many of which do not need rapid periodic updating. A single threaded architecture was initially utilised during testing. This was found to be impractical as the number of inputs and outputs became unmanageable using rapid polling. Reading from the \gls{rf} module is a blocking operation. This would cause the program to halt when fetching and reading the data from the \gls{rf} module. This could cause updates to the motor speeds and other sensors to be missed, potentially causing delays to the real time system. 

Because of this, the architecture was split into threads, listed in Table \ref{table:threads_for_reciever}. Each entry in the table is represented by a thread in the program that is initialised during start-up.

\begin{table}[H]
\centering
\setlength{\arrayrulewidth}{1.5pt}
\begin{tabular}{|p{0.4\linewidth}|p{0.4\linewidth}|}
\hline
\cellcolor{gray!40}Thread Name & \cellcolor{gray!40}Function \\ 
\hline
\cellcolor{gray!20}Left Motor Thread & \cellcolor{gray!20}Controls throttle Values of Left Motor\\
\hline
\cellcolor{gray!20}Right Motor Thread & \cellcolor{gray!20}Controls throttle Values of RIght Motor\\
\hline
\cellcolor{gray!20}Radio Thread & \cellcolor{gray!20}Used to handle incoming \gls{rf} Data\\
\hline
\cellcolor{gray!20}LED Thread & \cellcolor{gray!20}Used to change the LED status'\\
\hline
\cellcolor{gray!20}IR Thread & \cellcolor{gray!20}Used to handle interrupt from when litter collection basket is full\\
\hline
\cellcolor{gray!20}Input Thread & \cellcolor{gray!20}Used to handle inputs when flags raised\\
\hline
\cellcolor{gray!20}Battery 30 Percent Thread & \cellcolor{gray!20}Used to raise warning when battery is at 30 percent\\
\hline
\cellcolor{gray!20}Battery 15 Percent Thread & \cellcolor{gray!20}Used to raise warning when battery is at 15 percent\\
\hline
\end{tabular}
\caption{Threads for Receiver}
\label{table:threads_for_reciever}
\end{table}

\subsubsection{Serial Communications}

The serial communication for this project was done over \gls{spi} using nRF24L01 modules to send data. An overview of the serial communication can be seen in ยง\ref{sec:serial_communication_1}.

The main difference in serial communication on the receiver, is that it primarily uses receive mode. Therefore the setup for the \gls{rf} module is almost identical, except that it is initialised into receive mode. 

\begin{lstlisting}[language=C++,label=code:nRF24L01_SETUP_receiver,caption=nRF24L01 Set Up Receive Mode]
radio.powerUp();
radio.setTransferSize(TRANSFER_SIZE);
radio.setAirDataRate(NRF24L01P_DATARATE_2_MBPS);
radio.setRxAddress(NRF24L01_RX_ADDRESS);
radio.setTxAddress(NRF24L01_TX_ADDRESS);
radio.setReceiveMode();
radio.enable();
\end{lstlisting} 

The serial communication on the receiver board also used the transmission protocols, outlined in Appendix \ref{app:transmission_codes}. This allows the boards to communicate effectively.

To handle the incoming transmission codes, a separate radio thread is used, as shown in Table \ref{table:threads_for_reciever}. This thread does not cause any external blocking behaviour to any other threads. This allows the system to remain real time. 

\subsubsection{Buzzer API}

The buzzer \gls{api} used for the receiver is the same as used within the controller. This can be found at ยง\ref{sec:buzzer_api}.

\subsubsection{L298N API}

The \gls{dc} motors were driven using an off the shelf L298N motor controller. This required a simple \gls{api} to be written. This was to make the motors easier to control by abstracting functionality away from the user. 

This class has been written such that it is thread safe. The object-orientated nature of the class would allow the class to be used on any Mbed project that utilises an L298N to drive \gls{dc} motors. 

This \gls{api} uses four arguments, a motor A, a motor B, an enable, and a motor enabled. The motor enabled argument has a default value so it does not need to be used. If unused, the value will default to 0. This can be seen in Code \ref{code:L298N}.

\begin{lstlisting}[language=C++,label=code:L298N,caption=L298N Class Constructor]
#include "L298N.h"
L298N DCMotor1(PinName motorA, PinName motorB, PinName enable, int motorEnabled = 0);
\end{lstlisting} 

Using this \gls{api}, the motor can be enabled, disabled, and the direction can be set and read. These methods can be seen in Code \ref{code:L298N_methods}.

\begin{lstlisting}[language=C++,label=code:L298N_methods,caption=L298N Class Methods]
    void setDirection(int direction);
    void enableMotor();
    void disableMotor();
    int direction();
\end{lstlisting}

Given the nature of the motors being controller, basic \gls{dc} motors, the control was trivial. Despite this, abstracting this control made the motors easier to control within the main body of the code. 

\subsubsection{ESC API}

Unlike the brushed \gls{dc} motors, brushless motors require an \gls{esc} to operate. This requires more complex control to make the motor move. The \gls{esc}s require a \gls{pwm} signal that at 50Hz that varies between 1ms-2ms. This is similar to a servo control signal using a \gls{pwm} output \cite{PWM_control_of_an_ESC}. This class was inspired by the control system for servos. 

This class has been written such that it is thread safe. The object-orientated nature of the class allows the class to be used on any Mbed project that utilises an \gls{esc} that requires a 50Hz signal with a duty cycle varying between 1ms-2ms. 

The \gls{esc} \gls{api} uses  two arguments, the \gls{pwm} pin, and calibrate. The calibrate argument has a default value so this does not need to be used. If unused, the value will default to 0. This can be seen in Code \ref{code:ESC}.

\begin{lstlisting}[language=C++,label=code:ESC,caption=ESC Class Constructor]
#include "ESC.h"
ESC brushlessMotor(PinName pin, int calibrate = 0);
\end{lstlisting}

Using this \gls{api} the motors can be set a certain speed, have the \gls{pwm} value altered, and the value of speed can be read. This can be seen in Code \ref{code:ESC_methods}.

\begin{lstlisting}[language=C++,label=code:ESC_methods,caption=ESC Class Public Methods]
void write(float speed);
void setPWM(int PWMValue = DEFAULT_PWM_VALUE);
float speed();
\end{lstlisting}

This \gls{api} also contains private members, these are used to connect the \gls{esc}, calibrate the \gls{esc}, and normalise the speed values. These can be seen in Code \ref{code:ESC_private_methods}.

\begin{lstlisting}[language=C++,label=code:ESC_private_methods,caption=ESC Class Private Methods]
float normalise(float speed)
void connect();
void calibrate();
\end{lstlisting}

The normalise method is used to ensure that a value between 0-1 is written the \gls{esc}. If the value was not between these values, the \gls{esc} may not behave as expected. 

To connect the \gls{esc} the throttle value is set to its minimum value then held there until the \gls{esc} beeps. This can be a varying amount of time therefore 5s was chosen as this would be long enough for the \gls{esc} to connect. The calibration of the \gls{esc} is more complex. It requires the throttle value to be at its maximum value for 4s, then at it's minimum value for 4s. This allows the \gls{esc} to 'learn' the range of values that it is expecting as an input. This calibration should only be required for the first time the \gls{esc} and board are connected together, after this, the board remembers the previous values.

\subsubsection{Main Code}

The main code on the receiver board runs in eight threads. These have been outlined in Table \ref{table:threads_for_reciever}. The left and right motor threads, are for controlling the speed of the motors, the radio thread is for reading the serial data and either raising the appropriate flag for that action of performing an action dictated by the transmission codes. The LED thread is used for turning the LEDs on and off in a thread safe way that can be handled when the scheduler is available to, as these LEDs are less important than the functionality of the motors. The tother remaining four threads are all controlled by flags controlled by interrupts. This allows the inputs to be responsive whilst allowing the system to remain real time. 

When the \gls{ir} sensors get triggered, the \gls{isr} is triggered raising a flag to alert the board that the collection basket is full. This activates the \gls{ir} thread which disables the \gls{ir} \gls{isr}s and triggers the buzzer periodically. 

When the battery level is running low, the battery low input pins are pulled high. This triggers an \gls{isr} which periodically sounds the buzzer,. This alerts the user that the battery is running low.  

Table \ref{table:inputs_main_code} shows the functionality of the buttons and switches on the receiver board. 

\begin{table}[H]
\centering
\setlength{\arrayrulewidth}{1.5pt}
\begin{tabular}{|p{0.4\linewidth}|p{0.4\linewidth}|}
\hline
\cellcolor{gray!40}Input Name & \cellcolor{gray!40}Function \\ 
\hline
\cellcolor{gray!20} Button 1 & \cellcolor{gray!20} Disable Alarms and deactivate \gls{ir} sensors\\
\hline
\cellcolor{gray!20} Button 2 & \cellcolor{gray!20} Litter basket emptied, Resets Sensors and Enables Buzzer\\
\hline
\cellcolor{gray!20} Switch 1 & \cellcolor{gray!20} Disable Motors\\
\hline
\cellcolor{gray!20} Switch 2& \cellcolor{gray!20} Enable Motors\\
\hline
\cellcolor{gray!20} Switch 3 & \cellcolor{gray!20} Not in use\\
\hline
\cellcolor{gray!20} Switch 4 & \cellcolor{gray!20} Not in use\\
\hline
\cellcolor{gray!20} Switch 5 & \cellcolor{gray!20} Not in use\\
\hline
\cellcolor{gray!20} Switch 6 & \cellcolor{gray!20} Not in use\\
\hline

\end{tabular}
\caption{Functionality of Buttons and Switches in the Main Receiver Code }
\label{table:inputs_main_code}
\end{table}

